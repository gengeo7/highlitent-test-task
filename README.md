# Тестовое задание

## Запуск

Для корректной работе на windows надо использовать git bash/wsl (на windows не тестировал)

```sh
cp .env.example .env
docker compose up --build -d
```


## Тестирование

```sh
go test ./...
```

Я сделал только базовые unit тесты с минимумом тестируемой логики для экономии времени.
В проекте с данной архитектурой тривиально сделать integration тестирование
слоя сервисов с репозиторием используя testcontainers. Для тестирования эндпоинтов как пример разместил .http файлы.
Для коректной проверки эндпоинтов придется в ручную менять url.

## Стак/Библиотеки

- gorm
- goose
- net/http
- go-playground/validator
- godotenv
- uuid
- go-cmp

## Архитектура 

### Модули

Модули разделенны по слоям и в слоях находятся отдельные категории, например:

controllers
├── answers
│   ├── controller.go
│   └── test.http
└── questions
    ├── controller.go
    └── test.http

services
├── answers
│   ├── service.go
│   └── service_test.go
└── questions
    ├── service.go
    └── service_test.go

Такое разделение позволяет удобно производить поиск с помощью grep или ide инструментов.

### Слои

Класический controller -> service -> repository/storage

Controller слой сам по себе очень тонкий, его задача сводится на регистрацию коректных middleware, 
парсинга параметров и вызова коректных функций.

Services слой использует индивидуальные интерфейсы, что позволяет упростить тестирование и разорвать связь
с имплементацией repository слоя. При дальнейшей разроботки и усложнение работы Api (например пользователь
запращивает с флагом cache=true) слой сервиса не нуждается в изменение, нужно только дать вместо
имплементации на sql имплементацию redis. База данных, какая бы она не была дожна отдавать агностические ошибки
(например ErrDbNotFound вместо gorm.ErrRecordNotFound и так во всех имплементациях).

Repository/storage должен имплементировать интерфейсы, которые ожидают сервисы. В случае перехода с gorm на pgx
об этом будет знать только этот слой.


